// Enable experimental features for metadata access
Cesium.ExperimentalFeatures.enableModelExperimental = true;

var viewer = new Cesium.Viewer('cesiumContainer');

var testCase = "";
//testCase = "next/ImplicitTilesetWithTileMetadata";
//testCase = "next/TilesetWithExternalSchema";
//testCase = "next/TilesetWithGroupMetadata";
//testCase = "next/TilesetWithTileMetadata";
//testCase = "next/TilesetWithTilesetMetadata";
//testCase = "EXT_mesh_features/ExplicitFeatureIds";
//testCase = "EXT_mesh_features/ExplicitFeatureIdsAndSimpleProperty";
//testCase = "EXT_mesh_features/ImplicitFeatureIds";
//testCase = "EXT_mesh_features/ImplicitFeatureIdsAndSimpleProperty";
//testCase = "EXT_mesh_features/MultipleFeatureIdsAndProperties";
//testCase = "EXT_mesh_features/TwoPrimitivesOnePropertyTable";
//testCase = "EXT_mesh_features/SimpleFeatureIdTexture";
//testCase = "EXT_mesh_features/SimplePropertyTexture";
//testCase = "EXT_mesh_features/ComplexTypes";
testCase = "EXT_mesh_features/MultipleClasses";
//testCase = "SampleData/Cesium3DTiles/PointCloud/PointCloudBatched";
//testCase = "SampleData/Cesium3DTiles/Instanced/InstancedWithBatchTable";
//testCase = "SampleData/Cesium3DTiles/Batched/BatchedWithBatchTable";


// Create the tileset
var tileset = viewer.scene.primitives.add(new Cesium.Cesium3DTileset({
    url : 'http://localhost:8003/' + testCase + '/tileset.json',
    debugShowBoundingVolume: true
}));

// For EXT_mesh_features examples: Move the tileset to a 
// certain position on the globe
if (testCase.startsWith("EXT_mesh_features")) {
  tileset.modelMatrix = Cesium.Transforms.eastNorthUpToFixedFrame(
    Cesium.Cartesian3.fromDegrees(-75.1596759, 39.9509025, 0));
}

viewer.zoomTo(tileset);

// Create the label that will display metadata information
var labelEntity = viewer.entities.add({
  label: {
    showBackground: true,
    font: "14px monospace",
    horizontalOrigin: Cesium.HorizontalOrigin.LEFT,
    verticalOrigin: Cesium.VerticalOrigin.BOTTOM,
    pixelOffset: new Cesium.Cartesian2(10, -10),
    // Workaround to always render label on top:
    disableDepthTestDistance: Number.POSITIVE_INFINITY,
  },
});

// Returns an array of strings that each can be used for calling
// 'getProperty' on the given object. This is the result of 
// calling 'getPropertyIds' or 'getPropertyNames' on the 
// given object, if either of these functions exist. 
// Otherwise, returns an empty array.
var getPropertyKeys = function(metadata) {
  if (typeof(metadata.getPropertyIds) === "function") {
    return metadata.getPropertyIds();
  }
  if (typeof(metadata.getPropertyNames) === "function") {
    return metadata.getPropertyNames();
  }
  return [];
};

// Adds metadata information to the label, with 
// the given title indicating which granularity
// of metadata this is. The given metadata object
// can be a TilesetMetadata, TileMetadata, 
// ImplicitTileMetadata, or GroupMetadata.
// It's all just metadata, eventually...
var addMetadataToLabel = function(title, metadata) {
  if (!Cesium.defined(metadata)) {
    labelEntity.label.text += "(No " + title + ")\n";
    return;
  }
  var propertyKeys = getPropertyKeys(metadata);
  if (!Cesium.defined(propertyKeys)) {
    labelEntity.label.text += "(No properties for " + title + ")\n";
  }
  labelEntity.label.text += title + ":\n";
  for (var i=0; i<propertyKeys.length; i++) {
    var propertyKey = propertyKeys[i];
    var propertyValue = metadata.getProperty(propertyKey);          
    //console.log("propertyKey", propertyKey);
    //console.log("propertyValue", propertyValue);
    labelEntity.label.text += propertyKey + ": "+ propertyValue;
    labelEntity.label.text += "\n";
  }
};

// (NOTE: The way how metadata is obtained may be refactored,
// see https://github.com/CesiumGS/cesium/issues/10015 )

// Given an object that was obtained via Scene#pick, examine it 
// to see whether it contains tile metadata.
// If the object contains TileMetadata or ImplicitTileMetadata, 
// then this metadata is returned. 
// Otherwise, 'undefined' is returned.
var obtainTileMetadata = function(picked) {
  if (!Cesium.defined(picked)) {
    return undefined;
  }
  if (!Cesium.defined(picked.content)) {
    return undefined;
  }
  if (!Cesium.defined(picked.content.tile)) {
    return undefined;
  }
  if (!Cesium.defined(picked.content.tile.metadata)) {
    return undefined;
  }
  var metadata = picked.content.tile.metadata;
  var isTileMetadata = metadata instanceof Cesium.TileMetadata;
  var isImplicitTileMetadata = metadata instanceof Cesium.ImplicitTileMetadata;
  if (!isTileMetadata && !isImplicitTileMetadata) {
    return undefined;
  }
  return metadata;
};

// Given an object that was obtained via Scene#pick, examine it 
// to see whether it contains tileset metadata.
// If the object contains TilesetMetadata, then this metadata 
// is returned. 
// Otherwise, 'undefined' is returned.
var obtainTilesetMetadata = function(picked) {
  if (!Cesium.defined(picked)) {
    return undefined;
  }
  if (!Cesium.defined(picked.content)) {
    return undefined;
  }
  if (!Cesium.defined(picked.content.tileset)) {
    return undefined;
  }
  if (!Cesium.defined(picked.content.tileset.metadata)) {
    return undefined;
  }
  var metadata = picked.content.tileset.metadata.tileset;
  var isTilesetMetadata = metadata instanceof Cesium.TilesetMetadata;
  if (!isTilesetMetadata) {
    return undefined;
  }
  return metadata;
};

// Given an object that was obtained via Scene#pick, examine it 
// to see whether it contains group metadata.
// If the object contains GroupMetadata, then this metadata 
// is returned. 
// Otherwise, 'undefined' is returned.
var obtainGroupMetadata = function(picked) {
  if (!Cesium.defined(picked)) {
    return undefined;
  }
  if (!Cesium.defined(picked.content)) {
    return undefined;
  }
  if (!Cesium.defined(picked.content.groupMetadata)) {
    return undefined;
  }
  var metadata = picked.content.groupMetadata;
  var isGroupMetadata = metadata instanceof Cesium.GroupMetadata;
  if (!isGroupMetadata) {
    return undefined;
  }
  return metadata;
};

// Given an object that was obtained via Scene#pick, examine it 
// to see whether it contains feature metadata.
// If the object is a Cesium3DTileFeature, then it is returned.
// Otherwise, 'undefined' is returned.
var obtainFeatureMetadata = function(picked) {
  if (!Cesium.defined(picked)) {
    return undefined;
  }
  var metadata = picked;
  var isFeatureMetadata = metadata instanceof Cesium.Cesium3DTileFeature;
  if (!isFeatureMetadata) {
    return undefined;
  }
  return metadata;
};

// Install the handler that will perform picking when the 
// mouse is moved, and update the label entity when the 
// mouse is over something that contains metadata.
var handler = new Cesium.ScreenSpaceEventHandler(viewer.scene.canvas);
handler.setInputAction(function (movement) {
  labelEntity.label.text = "";
  var picked = viewer.scene.pick(movement.endPosition);
  
  console.log("picked ", picked);
  //debugger;
/*  
  var tilesetMetadata = obtainTilesetMetadata(picked);
  addMetadataToLabel("Tileset metadata", tilesetMetadata);

  var tileMetadata = obtainTileMetadata(picked);
  addMetadataToLabel("Tile metadata", tileMetadata);
  
  var groupMetadata = obtainGroupMetadata(picked);
  addMetadataToLabel("Group metadata", groupMetadata);
*/
  var featureMetadata = obtainFeatureMetadata(picked);
  var featureMetadataTitle = "Feature metadata";
  // TODO This could/should show the feature ID, even when
  // no metadata is associated with this ID...
  if (Cesium.defined(featureMetadata) &&
      picked instanceof Cesium.Cesium3DTileFeature) {
    featureMetadataTitle += " for feature ID " + picked.featureId;
  }
  addMetadataToLabel(featureMetadataTitle, featureMetadata);
  
  var cartesian = viewer.scene.pickPosition(movement.endPosition);
  labelEntity.position = cartesian;  
  
}, Cesium.ScreenSpaceEventType.MOUSE_MOVE);


// TODO Preliminary/experimental selection of feature ID index
var options = [
  {
    text: "FEATURE_ID_0",
    onselect: function () {
      tileset.featureIdIndex = 0;
    },
  },
  {
    text: "FEATURE_ID_1",
    onselect: function () {
      tileset.featureIdIndex = 1;
    },
  },
];

Sandcastle.addToolbarMenu(options);



